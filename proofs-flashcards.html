<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Proofs">
    <meta name="theme-color" content="#667eea">
    <title>Proofs Flashcards</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="proofs-manifest.json">

    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%23667eea' width='180' height='180' rx='40'/><text x='90' y='115' font-size='80' text-anchor='middle' fill='white'>∀</text></svg>">

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #34495e;
            --accent-color: #2980b9;
            --bg-color: #f4f6f7;
            --card-bg: #fff;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            margin: 0;
            padding: 20px;
            padding-top: calc(20px + var(--safe-top));
            padding-bottom: calc(20px + var(--safe-bottom));
            overflow-x: hidden;
        }

        html {
            height: -webkit-fill-available;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0 0 5px 0;
            font-size: 1.8rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        header p {
            margin: 0;
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .progress-bar {
            background: rgba(255,255,255,0.3);
            border-radius: 20px;
            height: 8px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: var(--success-color);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 20px;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            color: white;
            font-size: 0.85rem;
        }

        .category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .tab-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .tab-btn:hover, .tab-btn.active {
            background: white;
            color: var(--primary-color);
        }

        .flashcard-container {
            perspective: 1000px;
            margin: 15px 0;
            touch-action: pan-y;
        }

        .flashcard {
            position: relative;
            width: 100%;
            min-height: 380px;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.5s;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-face {
            position: absolute;
            width: 100%;
            min-height: 380px;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 20px;
            padding: 25px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.25);
        }

        .flashcard-front {
            background: white;
        }

        .flashcard-back {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            transform: rotateY(180deg);
        }

        .card-category {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #7f8c8d;
            font-weight: 600;
        }

        .card-number {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 0.8rem;
            color: #95a5a6;
        }

        .card-title {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 700;
        }

        .card-content {
            font-size: 1.05rem;
            color: #333;
            max-width: 95%;
        }

        .card-hint {
            position: absolute;
            bottom: 15px;
            font-size: 0.8rem;
            color: #bdc3c7;
        }

        .proof-section {
            background: #fff;
            border-left: 4px solid var(--accent-color);
            padding: 12px;
            margin-top: 10px;
            text-align: left;
            border-radius: 0 8px 8px 0;
            font-size: 0.9rem;
            max-height: 180px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .proof-section strong {
            color: var(--accent-color);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 15px;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            touch-action: manipulation;
        }

        .btn-prev, .btn-next {
            background: white;
            color: var(--primary-color);
            flex: 1;
            max-width: 120px;
        }

        .btn-prev:active, .btn-next:active {
            transform: scale(0.95);
        }

        .btn-shuffle {
            background: var(--warning-color);
            color: white;
            padding: 14px 20px;
        }

        .btn-shuffle:active {
            transform: scale(0.95);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .swipe-hint {
            text-align: center;
            color: rgba(255,255,255,0.7);
            font-size: 0.8rem;
            margin-top: 15px;
        }

        /* Install prompt banner */
        .install-banner {
            background: rgba(255,255,255,0.95);
            color: var(--primary-color);
            padding: 15px 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .install-banner.show {
            display: flex;
        }

        .install-banner p {
            margin: 0;
            font-size: 0.9rem;
            flex: 1;
        }

        .install-banner .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #95a5a6;
            cursor: pointer;
            padding: 0 0 0 15px;
        }

        /* Offline indicator */
        .offline-indicator {
            position: fixed;
            top: var(--safe-top);
            left: 0;
            right: 0;
            background: #e74c3c;
            color: white;
            text-align: center;
            padding: 8px;
            font-size: 0.85rem;
            display: none;
            z-index: 1000;
        }

        .offline-indicator.show {
            display: block;
        }

        @media (max-width: 400px) {
            .flashcard-face {
                min-height: 350px;
                padding: 20px;
            }
            .card-title {
                font-size: 1.3rem;
            }
            .card-content {
                font-size: 0.95rem;
            }
            .btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }
        }

        /* Prevent text selection on cards */
        .flashcard {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>

<div class="offline-indicator" id="offlineIndicator">
    You're offline - cards still work!
</div>

<div class="container">
    <div class="install-banner" id="installBanner">
        <p><strong>Add to Home Screen</strong><br>Tap <span style="font-size:1.2em">⎙</span> then "Add to Home Screen"</p>
        <button class="close-btn" onclick="dismissInstall()">&times;</button>
    </div>

    <header>
        <h1>Proofs Flashcards</h1>
        <p>Tap card to flip • Swipe to navigate</p>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="stats">
            <span>Card <span id="currentNum">1</span> of <span id="totalNum">0</span></span>
            <span id="categoryName">All Cards</span>
        </div>
    </header>

    <div class="category-tabs">
        <button class="tab-btn active" data-category="all">All</button>
        <button class="tab-btn" data-category="definition">Definitions</button>
        <button class="tab-btn" data-category="axiom">Axioms</button>
        <button class="tab-btn" data-category="theorem">Theorems</button>
        <button class="tab-btn" data-category="strategy">Strategies</button>
    </div>

    <div class="flashcard-container" id="flashcardContainer">
        <div class="flashcard" id="flashcard">
            <div class="flashcard-face flashcard-front">
                <span class="card-category" id="cardCategory">Definition</span>
                <span class="card-number" id="cardNumber">1/20</span>
                <div class="card-title" id="cardTitle">Loading...</div>
                <div class="card-content" id="cardFront"></div>
                <span class="card-hint">Tap to flip</span>
            </div>
            <div class="flashcard-face flashcard-back">
                <span class="card-category" id="cardCategoryBack">Definition</span>
                <span class="card-number" id="cardNumberBack">1/20</span>
                <div class="card-title" id="cardTitleBack">Answer</div>
                <div class="card-content" id="cardBack"></div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn btn-prev" id="prevBtn" onclick="prevCard()">← Prev</button>
        <button class="btn btn-shuffle" onclick="shuffleCards()">⟳</button>
        <button class="btn btn-next" id="nextBtn" onclick="nextCard()">Next →</button>
    </div>

    <div class="swipe-hint">
        Swipe left/right to navigate
    </div>
</div>

<script>
const allCards = [
    // Definitions
    {
        category: "definition",
        title: "Set Equality",
        front: "When are two sets A and B equal?",
        back: "\\(A = B \\iff A \\subseteq B \\text{ and } B \\subseteq A\\)"
    },
    {
        category: "definition",
        title: "Partition",
        front: "What is a partition of a set S?",
        back: "A collection of disjoint, non-empty subsets of \\(S\\) whose union is \\(S\\)."
    },
    {
        category: "definition",
        title: "Equivalence Relation",
        front: "What three properties define an equivalence relation?",
        back: "<strong>Reflexive</strong>, <strong>Symmetric</strong>, and <strong>Transitive</strong>"
    },
    {
        category: "definition",
        title: "Partial Order",
        front: "What three properties define a partial order?",
        back: "<strong>Reflexive</strong>, <strong>Antisymmetric</strong>, and <strong>Transitive</strong>"
    },
    {
        category: "definition",
        title: "Quotient Set",
        front: "What is the quotient set \\(S/\\sim\\)?",
        back: "The set of all equivalence classes formed by the relation \\(\\sim\\) on \\(S\\)."
    },
    {
        category: "definition",
        title: "Continuity",
        front: "When is a function f continuous at point c?",
        back: "\\(f\\) is continuous at \\(c\\) if \\(\\displaystyle\\lim_{x \\to c} f(x) = f(c)\\)<br><br>(Epsilon-delta definition required for proofs)"
    },
    {
        category: "definition",
        title: "Isomorphism",
        front: "What is an isomorphism?",
        back: "A <strong>structure-preserving bijection</strong> between two algebraic structures."
    },
    {
        category: "definition",
        title: "Injective / Surjective / Bijective",
        front: "Define: Injective, Surjective, Bijective",
        back: "<strong>Injective:</strong> One-to-one<br><strong>Surjective:</strong> Onto<br><strong>Bijective:</strong> Both (one-to-one and onto)"
    },

    // Axioms
    {
        category: "axiom",
        title: "Induction Principle",
        front: "What is the Principle of Mathematical Induction?",
        back: "The basis for proving statements for all natural numbers.<br><br>If \\(P(1)\\) is true and \\(P(k) \\Rightarrow P(k+1)\\), then \\(P(n)\\) is true for all \\(n \\in \\mathbb{N}\\)."
    },
    {
        category: "axiom",
        title: "Zorn's Lemma",
        front: "What is Zorn's Lemma used for?",
        back: "Finding <strong>maximal elements</strong> in partially ordered sets.<br><br>It is equivalent to (implies) the Axiom of Choice."
    },
    {
        category: "axiom",
        title: "Axiom of Choice",
        front: "State the Axiom of Choice",
        back: "Given any collection of non-empty sets, you can select exactly one element from each set in the collection."
    },
    {
        category: "axiom",
        title: "Axiom of Excluded Middle",
        front: "State the Axiom of Excluded Middle",
        back: "\\(P \\lor \\neg P\\) is always true.<br><br>Every proposition is either true or false."
    },

    // Theorems
    {
        category: "theorem",
        title: "Cantor's Theorem",
        front: "State Cantor's Theorem",
        back: "For any set \\(A\\):<br><br>\\(|A| < |\\mathcal{P}(A)|\\)<br><br>The cardinality of the power set is strictly greater than the cardinality of the set."
    },
    {
        category: "theorem",
        title: "Cantor's Theorem (Proof)",
        front: "How do you prove Cantor's Theorem?",
        back: "<div class='proof-section'><strong>Diagonalization:</strong><br>1. Assume surjection \\(f: A \\to \\mathcal{P}(A)\\) exists<br>2. Define \\(D = \\{x \\in A \\mid x \\notin f(x)\\}\\)<br>3. Since \\(f\\) is surjective, \\(\\exists d\\) with \\(f(d) = D\\)<br>4. Ask: Is \\(d \\in D\\)?<br>• If \\(d \\in D \\Rightarrow d \\notin f(d) = D\\). Contradiction!<br>• If \\(d \\notin D \\Rightarrow d \\in f(d) = D\\). Contradiction!<br>5. No such \\(f\\) exists. \\(\\square\\)</div>"
    },
    {
        category: "theorem",
        title: "Schröder-Bernstein",
        front: "State the Schröder-Bernstein Theorem",
        back: "If \\(|A| \\le |B|\\) and \\(|B| \\le |A|\\), then \\(|A| = |B|\\).<br><br>If injections \\(f: A \\to B\\) and \\(g: B \\to A\\) exist, then a bijection \\(h: A \\to B\\) exists."
    },
    {
        category: "theorem",
        title: "Fermat's Little Theorem",
        front: "State Fermat's Little Theorem",
        back: "If \\(p\\) is prime and \\(a\\) is an integer, then:<br><br>\\(a^p \\equiv a \\pmod{p}\\)"
    },
    {
        category: "theorem",
        title: "Fermat's Little Theorem (Proof)",
        front: "Prove Fermat's Little Theorem by induction",
        back: "<div class='proof-section'><strong>Induction on \\(a \\ge 0\\):</strong><br><strong>Base:</strong> \\(0^p = 0 \\equiv 0 \\pmod{p}\\) ✓<br><br><strong>Inductive Step:</strong> Assume \\(k^p \\equiv k\\).<br>By Binomial Theorem:<br>\\((k+1)^p = k^p + \\binom{p}{1}k^{p-1} + \\cdots + 1\\)<br><br>Since \\(p\\) is prime, \\(p \\mid \\binom{p}{i}\\) for \\(1 \\le i \\le p-1\\).<br>So \\((k+1)^p \\equiv k^p + 1 \\equiv k + 1 \\pmod{p}\\) \\(\\square\\)</div>"
    },
    {
        category: "theorem",
        title: "Russell's Paradox",
        front: "State Russell's Paradox",
        back: "There is no set of all sets."
    },
    {
        category: "theorem",
        title: "Russell's Paradox (Proof)",
        front: "Prove Russell's Paradox",
        back: "<div class='proof-section'>1. Suppose \\(U\\) = set of all sets exists<br>2. Define \\(R = \\{A \\in U \\mid A \\notin A\\}\\)<br>3. Ask: Is \\(R \\in R\\)?<br>• If \\(R \\in R \\Rightarrow R \\notin R\\). Contradiction!<br>• If \\(R \\notin R \\Rightarrow R \\in R\\). Contradiction!<br>4. Such \\(U\\) cannot exist. \\(\\square\\)</div>"
    },
    {
        category: "theorem",
        title: "Well-Ordering Principle",
        front: "State the Well-Ordering Principle",
        back: "Every non-empty subset of \\(\\mathbb{N}\\) has a <strong>least element</strong>."
    },
    {
        category: "theorem",
        title: "Well-Ordering (Proof)",
        front: "Prove the Well-Ordering Principle",
        back: "<div class='proof-section'><strong>Contrapositive via Strong Induction:</strong><br>Prove: If \\(S\\) has no least element, then \\(S = \\emptyset\\).<br><br>Let \\(P(n)\\) = \"\\(1, 2, \\ldots, n \\notin S\\)\"<br><br><strong>Base:</strong> \\(1 \\notin S\\) (else 1 is least). ✓<br><br><strong>Inductive:</strong> Assume \\(P(k)\\). If \\(k+1 \\in S\\), it would be least. So \\(k+1 \\notin S\\).<br><br>By induction, \\(\\forall n, n \\notin S\\), so \\(S = \\emptyset\\). \\(\\square\\)</div>"
    },
    {
        category: "theorem",
        title: "Infinitude of Primes",
        front: "Prove there are infinitely many primes",
        back: "<div class='proof-section'><strong>Euclid's Proof:</strong><br>1. Assume finitely many primes: \\(p_1, p_2, \\ldots, p_n\\)<br>2. Let \\(Q = p_1 p_2 \\cdots p_n + 1\\)<br>3. For each \\(p_i\\): \\(Q \\equiv 1 \\pmod{p_i}\\)<br>4. So no \\(p_i\\) divides \\(Q\\)<br>5. But \\(Q > 1\\) must have a prime factor<br>6. This prime isn't in our list. Contradiction! \\(\\square\\)</div>"
    },
    {
        category: "theorem",
        title: "Triangle Inequality",
        front: "State the Triangle Inequality",
        back: "For any \\(x, y \\in \\mathbb{R}\\):<br><br>\\(|x + y| \\le |x| + |y|\\)"
    },
    {
        category: "theorem",
        title: "Isomorphism Theorem",
        front: "When are two finite-dimensional vector spaces isomorphic?",
        back: "Two finite-dimensional vector spaces \\(V\\) and \\(W\\) over the same field \\(F\\) are isomorphic if and only if:<br><br>\\(\\dim(V) = \\dim(W)\\)"
    },

    // Strategies
    {
        category: "strategy",
        title: "Direct Proof",
        front: "What is a Direct Proof?",
        back: "Assume the hypothesis is true, then use logical steps to show the conclusion must be true.<br><br>To prove \\(P \\Rightarrow Q\\): Assume \\(P\\), derive \\(Q\\)."
    },
    {
        category: "strategy",
        title: "Proof by Contradiction",
        front: "What is Proof by Contradiction?",
        back: "Assume the statement is <strong>false</strong>, then derive a logical contradiction.<br><br>To prove \\(P\\): Assume \\(\\neg P\\), derive a contradiction, conclude \\(P\\)."
    },
    {
        category: "strategy",
        title: "Contrapositive",
        front: "What is Proof by Contrapositive?",
        back: "Prove \\(\\neg Q \\Rightarrow \\neg P\\) instead of \\(P \\Rightarrow Q\\).<br><br>These are logically equivalent."
    },
    {
        category: "strategy",
        title: "Mathematical Induction",
        front: "What are the steps for Mathematical Induction?",
        back: "<strong>1. Base Case:</strong> Prove \\(P(1)\\) is true<br><br><strong>2. Inductive Step:</strong> Assume \\(P(k)\\) is true (inductive hypothesis), prove \\(P(k+1)\\) is true<br><br><strong>3. Conclude:</strong> \\(P(n)\\) is true \\(\\forall n \\in \\mathbb{N}\\)"
    },
    {
        category: "strategy",
        title: "Strong Induction",
        front: "How does Strong Induction differ from regular induction?",
        back: "In the inductive step, you assume \\(P(1), P(2), \\ldots, P(k)\\) are <strong>all</strong> true to prove \\(P(k+1)\\).<br><br>Useful when \\(P(k+1)\\) depends on multiple previous cases."
    },
    {
        category: "strategy",
        title: "Proof by Cases",
        front: "What is Proof by Cases?",
        back: "Divide the problem into exhaustive cases and prove each one separately.<br><br>Ensure all possible cases are covered (no gaps)."
    },
    {
        category: "strategy",
        title: "Proof by Definition",
        front: "What is Proof by Definition?",
        back: "Apply the precise definition of a concept directly to prove the result.<br><br>Often the first step: unpack what the statement <em>means</em> by definition."
    }
];

let cards = [...allCards];
let currentIndex = 0;
let currentCategory = 'all';

// Load saved progress
function loadProgress() {
    const saved = localStorage.getItem('proofsFlashcardsProgress');
    if (saved) {
        const data = JSON.parse(saved);
        currentIndex = data.currentIndex || 0;
        currentCategory = data.currentCategory || 'all';
        filterCards(currentCategory, false);
    }
}

// Save progress
function saveProgress() {
    localStorage.setItem('proofsFlashcardsProgress', JSON.stringify({
        currentIndex,
        currentCategory
    }));
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function filterCards(category, resetIndex = true) {
    currentCategory = category;
    if (category === 'all') {
        cards = [...allCards];
    } else {
        cards = allCards.filter(c => c.category === category);
    }
    if (resetIndex) currentIndex = 0;
    if (currentIndex >= cards.length) currentIndex = 0;
    updateCard();
    updateCategoryName();
    saveProgress();

    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.category === category);
    });
}

function updateCategoryName() {
    const names = {
        'all': 'All Cards',
        'definition': 'Definitions',
        'axiom': 'Axioms',
        'theorem': 'Theorems',
        'strategy': 'Strategies'
    };
    document.getElementById('categoryName').textContent = names[currentCategory];
}

function updateCard() {
    if (cards.length === 0) return;

    const card = cards[currentIndex];
    const flashcard = document.getElementById('flashcard');

    // Remove flip
    flashcard.classList.remove('flipped');

    // Update content
    document.getElementById('cardCategory').textContent = card.category;
    document.getElementById('cardCategoryBack').textContent = card.category;
    document.getElementById('cardTitle').textContent = card.title;
    document.getElementById('cardTitleBack').textContent = card.title;
    document.getElementById('cardFront').innerHTML = card.front;
    document.getElementById('cardBack').innerHTML = card.back;

    // Update numbers
    const numText = `${currentIndex + 1}/${cards.length}`;
    document.getElementById('cardNumber').textContent = numText;
    document.getElementById('cardNumberBack').textContent = numText;
    document.getElementById('currentNum').textContent = currentIndex + 1;
    document.getElementById('totalNum').textContent = cards.length;

    // Update progress bar
    const progress = ((currentIndex + 1) / cards.length) * 100;
    document.getElementById('progressFill').style.width = progress + '%';

    // Update buttons
    document.getElementById('prevBtn').disabled = currentIndex === 0;
    document.getElementById('nextBtn').disabled = currentIndex === cards.length - 1;

    // Re-render MathJax
    if (window.MathJax) {
        MathJax.typesetPromise();
    }

    saveProgress();
}

function flipCard() {
    document.getElementById('flashcard').classList.toggle('flipped');
}

function nextCard() {
    if (currentIndex < cards.length - 1) {
        currentIndex++;
        updateCard();
    }
}

function prevCard() {
    if (currentIndex > 0) {
        currentIndex--;
        updateCard();
    }
}

function shuffleCards() {
    cards = shuffleArray([...cards]);
    currentIndex = 0;
    updateCard();
}

// Event listeners for category tabs
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => filterCards(btn.dataset.category));
});

// Keyboard controls
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
        e.preventDefault();
        flipCard();
    } else if (e.code === 'ArrowRight') {
        nextCard();
    } else if (e.code === 'ArrowLeft') {
        prevCard();
    } else if (e.code === 'KeyS') {
        shuffleCards();
    }
});

// Touch/swipe support
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;
let isSwiping = false;

const flashcardContainer = document.getElementById('flashcardContainer');
const flashcard = document.getElementById('flashcard');

flashcardContainer.addEventListener('touchstart', e => {
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
    isSwiping = false;
}, { passive: true });

flashcardContainer.addEventListener('touchmove', e => {
    const diffX = Math.abs(e.changedTouches[0].screenX - touchStartX);
    const diffY = Math.abs(e.changedTouches[0].screenY - touchStartY);
    if (diffX > diffY && diffX > 10) {
        isSwiping = true;
    }
}, { passive: true });

flashcardContainer.addEventListener('touchend', e => {
    touchEndX = e.changedTouches[0].screenX;
    touchEndY = e.changedTouches[0].screenY;

    const diffX = touchStartX - touchEndX;
    const diffY = Math.abs(touchStartY - touchEndY);

    if (Math.abs(diffX) > 50 && diffY < 100) {
        // Horizontal swipe
        if (diffX > 0) {
            nextCard();
        } else {
            prevCard();
        }
    } else if (!isSwiping && Math.abs(diffX) < 10) {
        // Tap
        flipCard();
    }
}, { passive: true });

// Install banner for iOS
function showInstallBanner() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isStandalone = window.navigator.standalone === true;
    const dismissed = localStorage.getItem('installBannerDismissed');

    if (isIOS && !isStandalone && !dismissed) {
        document.getElementById('installBanner').classList.add('show');
    }
}

function dismissInstall() {
    document.getElementById('installBanner').classList.remove('show');
    localStorage.setItem('installBannerDismissed', 'true');
}

// Offline detection
window.addEventListener('online', () => {
    document.getElementById('offlineIndicator').classList.remove('show');
});

window.addEventListener('offline', () => {
    document.getElementById('offlineIndicator').classList.add('show');
});

// Register service worker
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('proofs-sw.js').catch(() => {
        // Service worker registration failed, app still works
    });
}

// Initialize
loadProgress();
updateCard();
setTimeout(showInstallBanner, 2000);
</script>

</body>
</html>
